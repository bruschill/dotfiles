require 'spec_helper'

describe User do
  before(:each) do
    @attr = { :username => "frosty_acres", 
              :email => "brandon.ruschill@gmail.com", 
              :password => "password",
              :password_confirmation => "password" }
  end

  it "should create a new instance given valid attributes" do
    User.create!(@attr)
  end

  describe "basic user model validations" do
    describe "username validations" do
      it "should require a username" do
        no_name_user = User.new(@attr.merge(:username => ""))
        no_name_user.should_not be_valid
      end

      it "should reject usernames that are too long" do
        long_name = "a" * 21
        long_name_user  = User.new(@attr.merge(:username => long_name))
        long_name_user.should_not be_valid
      end

      it "should reject duplicate user names" do
        User.create!(@attr)
        duplicate_username_user = User.new(@attr)
        duplicate_username_user.should_not be_valid
      end

      it "should reject invalid usernames" do
        usernames = %w[_username -username user_-name user-_name ?username username?]

        usernames.each do |username|
          invalid_username_user = User.new(@attr.merge(:username => username))
          invalid_username_user.should_not be_valid
        end
      end

      it "should accept valid usernames" do
        usernames = %w[user_name user-name 1username username1 1243-1234 1234_1234]

        usernames.each do |username|
          valid_username_user = User.new(@attr.merge(:username => username))
          valid_username_user.should be_valid
        end
      end
    end

    describe "email validations" do
      it "should require an email address" do
        no_email_user = User.new(@attr.merge(:email => ""))
        no_email_user.should_not be_valid
      end

      it "should accept valid email addresses " do
        addresses = %w[user@foo.com THE_USER@foo.bar.org first.last@foo.jp]

        addresses.each do |address|
          valid_email_user = User.new(@attr.merge(:email => address))
          valid_email_user.should be_valid
        end
      end

      it "should reject invalid email addresses" do
        addresses = %w[user@foo,com user_at_foo.org example.user@foo.]
        
        addresses.each do |address|
          invalid_email_user = User.new(@attr.merge(:email => address))
          invalid_email_user.should_not be_valid
        end
      end

      it "should reject duplicate email addresses" do
        User.create!(@attr)
        user_with_duplicate_email = User.new(@attr)
        user_with_duplicate_email.should_not be_valid
      end

      it "should reject email addresses identitcal up to case" do
        upcased_email = @attr[:email].upcase
        User.create!(@attr.merge(:email => upcased_email))
        user_with_duplicate_email = User.new(@attr)
        user_with_duplicate_email.should_not be_valid
      end
    end

    describe "password validations" do
      it "should require a password" do
        no_password_user = User.new(@attr.merge(:password => "", :password_confirmation => ""))
        no_password_user.should_not be_valid
      end

      it "should require a matching password confirmation" do
        invalid_password_confirmation_user = User.new(@attr.merge(:password_confirmation => "invalid"))
        invalid_password_confirmation_user.should_not be_valid
      end

      it "should accept valid passwords" do
        valid_passwords = ['a' * 6, 'a' * 40]

        valid_passwords.each do |password|
          valid_email_user = User.new(@attr.merge(:password => password, :password_confirmation => password))
          valid_email_user.should be_valid
        end
      end

      it "should reject invalid passwords" do
        invalid_passwords = ["", 'a' * 5, 'a' * 41]

        invalid_passwords.each do |password|
          invalid_password_user = User.new(@attr.merge(:password => password, :password_confirmation => password))
          invalid_password_user.should_not be_valid
        end
      end
    end

    describe "password encryption" do
      before(:each) do
        @user = User.create!(@attr)
      end

      it "should have an encrypted password attribute" do
        @user.should respond_to(:encrypted_password)
      end 

      it "should set the encrypted password" do
        @user.encrypted_password.should_not be_blank 
      end

      describe "has_password? method" do
        it "should be true if passwords match" do
          @user.has_password?(@attr[:password]).should be_true
        end

        it "should be false if passwords don't match" do
          @user.has_password?("invalid").should be_false
        end
      end

      describe "authenticate method" do
        it "should return nil on email/password mismatch" do
          wrong_password_user = User.authenticate(@attr[:username], "wrongname")
          wrong_password_user.should be_nil
        end

        it "should return nil for an username with no user" do
          nonexistent_user = User.authenticate("zzzabccom", @attr[:password])
          nonexistent_user.should be_nil
        end

        it "should return the user on username/password match" do
          matching_user = User.authenticate(@attr[:username], @attr[:password])
          matching_user.should == @user
        end
      end
    end
  end

  describe "task list associations" do
    before(:each) do
      @user = User.new(@attr)
      @tl1 = Tasklist.create!(:title => "First task list")
      @tl2 = Tasklist.create!(:title => "Second task list")

      @user.tasklists = [@tl1, @tl2]
    end

    it "should have a tasklists attribute" do
      @user.should respond_to(:tasklists)
    end

    it "should be able to have tasklists associated with it" do
      @user.id.should == @tl1.user_id
      @user.id.should == @tl2.user_id
    end
  end
end
